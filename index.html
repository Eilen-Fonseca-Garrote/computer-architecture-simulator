<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Arquitectura de Computadoras</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #333;
        }
        .tab-container {
            margin-bottom: 20px;
        }
        .tab-buttons {
            display: flex;
            margin-bottom: 10px;
        }
        .tab-button {
            padding: 10px 20px;
            background-color: #eee;
            border: none;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 4px 4px 0 0;
        }
        .tab-button.active {
            background-color: #4CAF50;
            color: white;
        }
        .tab-content {
            display: none;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 0 0 4px 4px;
        }
        .tab-content.active {
            display: block;
        }
        .register {
            display: inline-block;
            padding: 10px;
            margin: 5px;
            background-color: #e0e0e0;
            border-radius: 4px;
            min-width: 100px;
            text-align: center;
        }
        .register.active {
            background-color: #4CAF50;
            color: white;
        }
        .memory-cell {
            display: inline-block;
            width: 80px;
            padding: 5px;
            margin: 2px;
            border: 1px solid #ccc;
            text-align: center;
            background-color: #f9f9f9;
        }
        .memory-cell.active {
            background-color: #4CAF50;
            color: white;
        }
        .cache-line {
            display: flex;
            margin-bottom: 5px;
            border: 1px solid #ccc;
            padding: 5px;
        }
        .cache-field {
            flex: 1;
            padding: 5px;
            text-align: center;
            border-right: 1px solid #ccc;
        }
        .cache-field:last-child {
            border-right: none;
        }
        .cache-line.active {
            background-color: #4CAF50;
            color: white;
        }
        .button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        .button:hover {
            background-color: #45a049;
        }
        .button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .log {
            margin-top: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
        }
        .step-explanation {
            margin-top: 10px;
            padding: 10px;
            background-color: #e8f4fd;
            border-radius: 4px;
        }
        .animation-area {
            border: 1px solid #ddd;
            padding: 20px;
            margin: 10px 0;
            min-height: 200px;
            position: relative;
        }
        .data-block {
            position: absolute;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            border-radius: 4px;
            transition: all 1s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Simulador de Arquitectura de Computadoras</h1>
        
        <div class="tab-container">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="openTab('machine-tab')">Máquina Hipotética</button>
                <button class="tab-button" onclick="openTab('cache-tab')">Memoria Caché</button>
            </div>
            
            <!-- Pestaña de Máquina Hipotética -->
            <div id="machine-tab" class="tab-content active">
                <h2>Simulación de Máquina Hipotética</h2>
                
                <div>
                    <h3>Registros</h3>
                    <div id="registers">
                        <div class="register" id="ac">AC: 0</div>
                        <div class="register" id="pc">PC: 0</div>
                        <div class="register" id="ir">IR: 0</div>
                        <div class="register" id="mar">MAR: 0</div>
                        <div class="register" id="mbr">MBR: 0</div>
                    </div>
                </div>
                
                <div>
                    <h3>Memoria</h3>
                    <div id="memory"></div>
                </div>
                
                <div>
                    <h3>Programa</h3>
                    <textarea id="program-code" rows="10" cols="50">
LOAD 10
ADD 11
STORE 12
LOAD 12
                    </textarea>
                    <br>
                    <button class="button" onclick="loadProgram()">Cargar Programa</button>
                    <button class="button" id="step-btn" onclick="stepMachine()" disabled>Ejecutar Paso</button>
                    <button class="button" onclick="resetMachine()">Reiniciar</button>
                </div>
                
                <div class="animation-area" id="machine-animation">
                    <!-- Aquí se mostrarán las animaciones -->
                </div>
                
                <div class="step-explanation" id="machine-explanation">
                    <!-- Aquí se explicará cada paso -->
                </div>
                
                <div class="log" id="machine-log">
                    <!-- Aquí se mostrará el log de ejecución -->
                </div>
            </div>
            
            <!-- Pestaña de Memoria Caché -->
            <div id="cache-tab" class="tab-content">
                <h2>Simulación de Memoria Caché</h2>
                
                <div>
                    <label for="mapping-type">Tipo de Correspondencia:</label>
                    <select id="mapping-type" onchange="changeMappingType()">
                        <option value="direct">Directa</option>
                        <option value="set-associative">Asociativa por Conjuntos</option>
                        <option value="fully-associative">Totalmente Asociativa</option>
                    </select>
                    
                    <div id="cache-config" style="margin-top: 10px;">
                        <!-- Configuración específica para cada tipo -->
                    </div>
                    
                    <div style="margin-top: 10px;">
                        <label for="memory-address">Dirección de Memoria:</label>
                        <input type="text" id="memory-address" placeholder="Ej: 1010">
                        <button class="button" onclick="accessMemory()">Acceder a Memoria</button>
                        <button class="button" onclick="resetCache()">Reiniciar Caché</button>
                    </div>
                </div>
                
                <div>
                    <h3>Memoria Caché</h3>
                    <div id="cache-display"></div>
                </div>
                
                <div class="animation-area" id="cache-animation">
                    <!-- Aquí se mostrarán las animaciones de la caché -->
                </div>
                
                <div class="step-explanation" id="cache-explanation">
                    <!-- Aquí se explicará cada paso del acceso a caché -->
                </div>
                
                <div class="log" id="cache-log">
                    <!-- Aquí se mostrará el log de accesos a caché -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========== MÁQUINA HIPOTÉTICA ==========
        
        // Estado de la máquina
        let machineState = {
            ac: 0,
            pc: 0,
            ir: 0,
            mar: 0,
            mbr: 0,
            memory: new Array(16).fill(0),
            program: [],
            running: false,
            currentStep: 0
        };
        
        // Inicializar la memoria en la UI
        function initializeMemory() {
            const memoryDiv = document.getElementById('memory');
            memoryDiv.innerHTML = '';
            
            for (let i = 0; i < machineState.memory.length; i++) {
                const cell = document.createElement('div');
                cell.className = 'memory-cell';
                cell.id = `mem-${i}`;
                cell.textContent = `[${i}]: ${machineState.memory[i]}`;
                memoryDiv.appendChild(cell);
            }
        }
        
        // Cargar programa desde el textarea
        function loadProgram() {
            const programText = document.getElementById('program-code').value;
            const lines = programText.split('\n');
            machineState.program = [];
            
            // Inicializar memoria con ceros
            machineState.memory = new Array(16).fill(0);
            
            // Parsear instrucciones y cargar en memoria
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim().toUpperCase();
                if (line === '') continue;
                
                const parts = line.split(' ');
                const instruction = parts[0];
                const address = parts.length > 1 ? parseInt(parts[1]) : 0;
                
                // Codificar instrucción (simplificado)
                let encodedInstruction = 0;
                if (instruction === 'LOAD') {
                    encodedInstruction = 0x1000 | address; // Opcode 1
                } else if (instruction === 'STORE') {
                    encodedInstruction = 0x2000 | address; // Opcode 2
                } else if (instruction === 'ADD') {
                    encodedInstruction = 0x3000 | address; // Opcode 3
                }
                
                machineState.memory[i] = encodedInstruction;
                machineState.program.push({ instruction, address, line: i });
            }
            
            // Inicializar estado
            machineState.ac = 0;
            machineState.pc = 0;
            machineState.ir = 0;
            machineState.mar = 0;
            machineState.mbr = 0;
            machineState.running = true;
            machineState.currentStep = 0;
            
            // Actualizar UI
            updateRegisters();
            initializeMemory();
            document.getElementById('step-btn').disabled = false;
            document.getElementById('machine-log').innerHTML = 'Programa cargado. Listo para ejecutar.';
        }
        
        // Actualizar visualización de registros
        function updateRegisters() {
            document.getElementById('ac').textContent = `AC: ${machineState.ac}`;
            document.getElementById('pc').textContent = `PC: ${machineState.pc}`;
            document.getElementById('ir').textContent = `IR: ${machineState.ir.toString(16).toUpperCase()}`;
            document.getElementById('mar').textContent = `MAR: ${machineState.mar}`;
            document.getElementById('mbr').textContent = `MBR: ${machineState.mbr}`;
        }
        
        // Resaltar elemento activo
        function highlightElement(id, isActive) {
            const element = document.getElementById(id);
            if (element) {
                if (isActive) {
                    element.classList.add('active');
                } else {
                    element.classList.remove('active');
                }
            }
        }
        
        // Ejecutar un paso de la máquina
        function stepMachine() {
            if (!machineState.running || machineState.pc >= machineState.program.length) {
                document.getElementById('machine-log').innerHTML += '<br>Ejecución completada.';
                document.getElementById('step-btn').disabled = true;
                return;
            }
            
            const step = machineState.currentStep % 3; // 0: fetch, 1: decode, 2: execute
            let explanation = '';
            let logEntry = '';
            
            // Limpiar highlights anteriores
            document.querySelectorAll('.register, .memory-cell').forEach(el => {
                el.classList.remove('active');
            });
            
            if (step === 0) { // Fetch
                explanation = 'Paso 1: Búsqueda de instrucción (FETCH)';
                logEntry = `FETCH: PC=${machineState.pc}`;
                
                // MAR <- PC
                machineState.mar = machineState.pc;
                highlightElement('mar', true);
                highlightElement('pc', true);
                
                // MBR <- Memoria[MAR]
                machineState.mbr = machineState.memory[machineState.mar];
                highlightElement('mbr', true);
                highlightElement(`mem-${machineState.mar}`, true);
                
                // IR <- MBR
                machineState.ir = machineState.mbr;
                highlightElement('ir', true);
                
                // PC <- PC + 1
                machineState.pc++;
                
            } else if (step === 1) { // Decode
                explanation = 'Paso 2: Decodificación de instrucción (DECODE)';
                logEntry = `DECODE: IR=${machineState.ir.toString(16).toUpperCase()}`;
                
                // Decodificar instrucción
                const opcode = (machineState.ir & 0xF000) >> 12;
                const address = machineState.ir & 0x0FFF;
                
                machineState.mar = address;
                highlightElement('mar', true);
                highlightElement('ir', true);
                
                if (opcode === 1) {
                    explanation += '<br>Instrucción: LOAD (cargar dato de memoria a AC)';
                } else if (opcode === 2) {
                    explanation += '<br>Instrucción: STORE (guardar AC en memoria)';
                } else if (opcode === 3) {
                    explanation += '<br>Instrucción: ADD (sumar dato de memoria a AC)';
                }
                
            } else if (step === 2) { // Execute
                explanation = 'Paso 3: Ejecución de instrucción (EXECUTE)';
                
                // Decodificar instrucción
                const opcode = (machineState.ir & 0xF000) >> 12;
                const address = machineState.ir & 0x0FFF;
                
                if (opcode === 1) { // LOAD
                    // MBR <- Memoria[MAR]
                    machineState.mbr = machineState.memory[machineState.mar];
                    highlightElement('mbr', true);
                    highlightElement(`mem-${machineState.mar}`, true);
                    
                    // AC <- MBR
                    machineState.ac = machineState.mbr;
                    highlightElement('ac', true);
                    
                    logEntry = `EXECUTE: LOAD ${address} -> AC=${machineState.ac}`;
                    explanation += `<br>Ejecutando LOAD: Cargando valor ${machineState.mbr} de memoria[${address}] al registro AC`;
                    
                } else if (opcode === 2) { // STORE
                    // MBR <- AC
                    machineState.mbr = machineState.ac;
                    highlightElement('mbr', true);
                    highlightElement('ac', true);
                    
                    // Memoria[MAR] <- MBR
                    machineState.memory[machineState.mar] = machineState.mbr;
                    highlightElement(`mem-${machineState.mar}`, true);
                    
                    logEntry = `EXECUTE: STORE AC=${machineState.ac} -> memoria[${address}]`;
                    explanation += `<br>Ejecutando STORE: Guardando valor ${machineState.ac} del registro AC a memoria[${address}]`;
                    
                } else if (opcode === 3) { // ADD
                    // MBR <- Memoria[MAR]
                    machineState.mbr = machineState.memory[machineState.mar];
                    highlightElement('mbr', true);
                    highlightElement(`mem-${machineState.mar}`, true);
                    
                    // AC <- AC + MBR
                    machineState.ac += machineState.mbr;
                    highlightElement('ac', true);
                    
                    logEntry = `EXECUTE: ADD ${address} (valor=${machineState.mbr}) -> AC=${machineState.ac}`;
                    explanation += `<br>Ejecutando ADD: Sumando valor ${machineState.mbr} de memoria[${address}] al registro AC`;
                }
                
                // Actualizar visualización de memoria
                initializeMemory();
            }
            
            // Actualizar UI
            updateRegisters();
            document.getElementById('machine-explanation').innerHTML = explanation;
            document.getElementById('machine-log').innerHTML += '<br>' + logEntry;
            document.getElementById('machine-log').scrollTop = document.getElementById('machine-log').scrollHeight;
            
            machineState.currentStep++;
            
            // Si completamos una instrucción, avanzamos al siguiente fetch
            if (step === 2 && machineState.pc >= machineState.program.length) {
                document.getElementById('machine-log').innerHTML += '<br>Ejecución completada.';
                document.getElementById('step-btn').disabled = true;
                machineState.running = false;
            }
        }
        
        // Reiniciar máquina
        function resetMachine() {
            machineState.ac = 0;
            machineState.pc = 0;
            machineState.ir = 0;
            machineState.mar = 0;
            machineState.mbr = 0;
            machineState.memory = new Array(16).fill(0);
            machineState.running = false;
            machineState.currentStep = 0;
            
            updateRegisters();
            initializeMemory();
            document.getElementById('step-btn').disabled = true;
            document.getElementById('machine-explanation').innerHTML = '';
            document.getElementById('machine-log').innerHTML = 'Máquina reiniciada.';
        }
        
        // ========== MEMORIA CACHÉ ==========
        
        // Estado de la caché
        let cacheState = {
            type: 'direct',
            cache: [],
            mainMemory: new Array(64).fill(0).map((_, i) => i), // Memoria principal con valores 0-63
            accessCount: 0,
            hitCount: 0
        };
        
        // Cambiar tipo de correspondencia
        function changeMappingType() {
            cacheState.type = document.getElementById('mapping-type').value;
            resetCache();
            updateCacheConfig();
        }
        
        // Actualizar configuración de caché según el tipo
        function updateCacheConfig() {
            const configDiv = document.getElementById('cache-config');
            
            if (cacheState.type === 'direct') {
                configDiv.innerHTML = `
                    <p><strong>Correspondencia Directa</strong></p>
                    <p>Características:</p>
                    <ul>
                        <li>Cada bloque de memoria tiene una única posición en caché</li>
                        <li>Fácil de implementar pero puede causar conflictos</li>
                    </ul>
                    <p>Configuración actual: 8 líneas de caché, bloques de 1 palabra</p>
                `;
            } else if (cacheState.type === 'set-associative') {
                configDiv.innerHTML = `
                    <p><strong>Correspondencia Asociativa por Conjuntos</strong></p>
                    <p>Características:</p>
                    <ul>
                        <li>La caché se divide en conjuntos</li>
                        <li>Cada bloque puede ir en cualquier línea de su conjunto</li>
                        <li>Balance entre flexibilidad y complejidad</li>
                    </ul>
                    <p>Configuración actual: 4 conjuntos, 2 vías (2 líneas por conjunto)</p>
                `;
            } else if (cacheState.type === 'fully-associative') {
                configDiv.innerHTML = `
                    <p><strong>Correspondencia Totalmente Asociativa</strong></p>
                    <p>Características:</p>
                    <ul>
                        <li>Cualquier bloque puede ir en cualquier línea de caché</li>
                        <li>Máxima flexibilidad pero más compleja de implementar</li>
                        <li>Requiere política de reemplazo (LRU, FIFO, etc.)</li>
                    </ul>
                    <p>Configuración actual: 8 líneas de caché, política LRU</p>
                `;
            }
            
            initializeCache();
        }
        
        // Inicializar caché según el tipo
        function initializeCache() {
            cacheState.cache = [];
            
            if (cacheState.type === 'direct') {
                // 8 líneas de caché para correspondencia directa
                for (let i = 0; i < 8; i++) {
                    cacheState.cache.push({
                        valid: false,
                        tag: 0,
                        data: 0,
                        accessTime: 0
                    });
                }
            } else if (cacheState.type === 'set-associative') {
                // 4 conjuntos, 2 vías (total 8 líneas)
                for (let set = 0; set < 4; set++) {
                    cacheState.cache[set] = [];
                    for (let way = 0; way < 2; way++) {
                        cacheState.cache[set].push({
                            valid: false,
                            tag: 0,
                            data: 0,
                            accessTime: 0
                        });
                    }
                }
            } else if (cacheState.type === 'fully-associative') {
                // 8 líneas para correspondencia totalmente asociativa
                for (let i = 0; i < 8; i++) {
                    cacheState.cache.push({
                        valid: false,
                        tag: 0,
                        data: 0,
                        accessTime: 0
                    });
                }
            }
            
            cacheState.accessCount = 0;
            cacheState.hitCount = 0;
            updateCacheDisplay();
        }
        
        // Actualizar visualización de la caché
        function updateCacheDisplay() {
            const cacheDiv = document.getElementById('cache-display');
            cacheDiv.innerHTML = '';
            
            if (cacheState.type === 'direct') {
                // Mostrar caché de correspondencia directa
                const table = document.createElement('table');
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                
                // Encabezado
                const header = table.insertRow();
                header.innerHTML = '<th>Línea</th><th>Válido</th><th>Etiqueta</th><th>Dato</th><th>Último Acceso</th>';
                
                // Filas de datos
                for (let i = 0; i < cacheState.cache.length; i++) {
                    const row = table.insertRow();
                    row.innerHTML = `
                        <td style="border: 1px solid #ccc; padding: 5px;">${i}</td>
                        <td style="border: 1px solid #ccc; padding: 5px;">${cacheState.cache[i].valid ? 'Sí' : 'No'}</td>
                        <td style="border: 1px solid #ccc; padding: 5px;">${cacheState.cache[i].tag.toString(2).padStart(3, '0')}</td>
                        <td style="border: 1px solid #ccc; padding: 5px;">${cacheState.cache[i].data}</td>
                        <td style="border: 1px solid #ccc; padding: 5px;">${cacheState.cache[i].accessTime}</td>
                    `;
                }
                
                cacheDiv.appendChild(table);
                
            } else if (cacheState.type === 'set-associative') {
                // Mostrar caché asociativa por conjuntos
                for (let set = 0; set < cacheState.cache.length; set++) {
                    const setDiv = document.createElement('div');
                    setDiv.innerHTML = `<h4>Conjunto ${set}</h4>`;
                    
                    const table = document.createElement('table');
                    table.style.width = '100%';
                    table.style.borderCollapse = 'collapse';
                    table.style.marginBottom = '10px';
                    
                    // Encabezado
                    const header = table.insertRow();
                    header.innerHTML = '<th>Vía</th><th>Válido</th><th>Etiqueta</th><th>Dato</th><th>Último Acceso</th>';
                    
                    // Filas de datos
                    for (let way = 0; way < cacheState.cache[set].length; way++) {
                        const row = table.insertRow();
                        row.innerHTML = `
                            <td style="border: 1px solid #ccc; padding: 5px;">${way}</td>
                            <td style="border: 1px solid #ccc; padding: 5px;">${cacheState.cache[set][way].valid ? 'Sí' : 'No'}</td>
                            <td style="border: 1px solid #ccc; padding: 5px;">${cacheState.cache[set][way].tag.toString(2).padStart(4, '0')}</td>
                            <td style="border: 1px solid #ccc; padding: 5px;">${cacheState.cache[set][way].data}</td>
                            <td style="border: 1px solid #ccc; padding: 5px;">${cacheState.cache[set][way].accessTime}</td>
                        `;
                    }
                    
                    setDiv.appendChild(table);
                    cacheDiv.appendChild(setDiv);
                }
                
            } else if (cacheState.type === 'fully-associative') {
                // Mostrar caché totalmente asociativa
                const table = document.createElement('table');
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                
                // Encabezado
                const header = table.insertRow();
                header.innerHTML = '<th>Línea</th><th>Válido</th><th>Etiqueta</th><th>Dato</th><th>Último Acceso</th>';
                
                // Filas de datos
                for (let i = 0; i < cacheState.cache.length; i++) {
                    const row = table.insertRow();
                    row.innerHTML = `
                        <td style="border: 1px solid #ccc; padding: 5px;">${i}</td>
                        <td style="border: 1px solid #ccc; padding: 5px;">${cacheState.cache[i].valid ? 'Sí' : 'No'}</td>
                        <td style="border: 1px solid #ccc; padding: 5px;">${cacheState.cache[i].tag.toString(2).padStart(6, '0')}</td>
                        <td style="border: 1px solid #ccc; padding: 5px;">${cacheState.cache[i].data}</td>
                        <td style="border: 1px solid #ccc; padding: 5px;">${cacheState.cache[i].accessTime}</td>
                    `;
                }
                
                cacheDiv.appendChild(table);
            }
            
            // Mostrar estadísticas
            const statsDiv = document.createElement('div');
            statsDiv.style.marginTop = '10px';
            statsDiv.innerHTML = `
                <p><strong>Estadísticas:</strong></p>
                <p>Accesos totales: ${cacheState.accessCount}</p>
                <p>Aciertos: ${cacheState.hitCount}</p>
                <p>Fallos: ${cacheState.accessCount - cacheState.hitCount}</p>
                <p>Tasa de aciertos: ${cacheState.accessCount > 0 ? (cacheState.hitCount / cacheState.accessCount * 100).toFixed(2) : 0}%</p>
            `;
            cacheDiv.appendChild(statsDiv);
        }
        
        // Acceder a memoria (simular acceso a caché)
        function accessMemory() {
            const addressInput = document.getElementById('memory-address').value;
            if (!addressInput) {
                alert('Por favor, ingrese una dirección de memoria');
                return;
            }
            
            const address = parseInt(addressInput);
            if (isNaN(address) || address < 0 || address >= cacheState.mainMemory.length) {
                alert(`Dirección inválida. Debe estar entre 0 y ${cacheState.mainMemory.length - 1}`);
                return;
            }
            
            cacheState.accessCount++;
            let explanation = `<strong>Acceso a dirección ${address} (binario: ${address.toString(2).padStart(6, '0')})</strong><br>`;
            let hit = false;
            let data = cacheState.mainMemory[address];
            
            // Limpiar animación anterior
            document.getElementById('cache-animation').innerHTML = '';
            
            if (cacheState.type === 'direct') {
                // Correspondencia directa
                const indexBits = 3; // 8 líneas -> 3 bits para índice
                const tagBits = 6 - indexBits; // 6 bits de dirección total
                
                const index = (address >> 0) & 0b111; // Últimos 3 bits para índice
                const tag = (address >> indexBits) & ((1 << tagBits) - 1); // Primeros 3 bits para etiqueta
                
                explanation += `Desglose de dirección:<br>`;
                explanation += `- Etiqueta: ${tag.toString(2).padStart(tagBits, '0')} (${tag})<br>`;
                explanation += `- Índice: ${index.toString(2).padStart(indexBits, '0')} (${index})<br>`;
                explanation += `- Desplazamiento: 0 (bloques de 1 palabra)<br><br>`;
                
                explanation += `Buscando en línea ${index} de la caché...<br>`;
                
                if (cacheState.cache[index].valid && cacheState.cache[index].tag === tag) {
                    // Hit
                    hit = true;
                    cacheState.hitCount++;
                    cacheState.cache[index].accessTime = cacheState.accessCount;
                    explanation += `¡ACIERTO! Datos encontrados en caché: ${cacheState.cache[index].data}<br>`;
                } else {
                    // Miss
                    explanation += `FALLO. Datos no encontrados en caché.<br>`;
                    explanation += `Cargando datos desde memoria principal...<br>`;
                    
                    // Reemplazar línea de caché
                    cacheState.cache[index].valid = true;
                    cacheState.cache[index].tag = tag;
                    cacheState.cache[index].data = data;
                    cacheState.cache[index].accessTime = cacheState.accessCount;
                    
                    explanation += `Línea ${index} actualizada con etiqueta ${tag.toString(2).padStart(tagBits, '0')} y dato ${data}<br>`;
                }
                
            } else if (cacheState.type === 'set-associative') {
                // Correspondencia asociativa por conjuntos (2 vías)
                const indexBits = 2; // 4 conjuntos -> 2 bits para índice
                const tagBits = 6 - indexBits; // 4 bits para etiqueta
                
                const index = (address >> 0) & 0b11; // Últimos 2 bits para índice del conjunto
                const tag = (address >> indexBits) & ((1 << tagBits) - 1); // Primeros 4 bits para etiqueta
                
                explanation += `Desglose de dirección:<br>`;
                explanation += `- Etiqueta: ${tag.toString(2).padStart(tagBits, '0')} (${tag})<br>`;
                explanation += `- Índice (conjunto): ${index.toString(2).padStart(indexBits, '0')} (${index})<br>`;
                explanation += `- Desplazamiento: 0 (bloques de 1 palabra)<br><br>`;
                
                explanation += `Buscando en conjunto ${index} de la caché...<br>`;
                
                const set = cacheState.cache[index];
                let found = false;
                
                // Buscar en todas las vías del conjunto
                for (let way = 0; way < set.length; way++) {
                    if (set[way].valid && set[way].tag === tag) {
                        // Hit
                        hit = true;
                        found = true;
                        cacheState.hitCount++;
                        set[way].accessTime = cacheState.accessCount;
                        explanation += `¡ACIERTO! Datos encontrados en vía ${way}: ${set[way].data}<br>`;
                        break;
                    }
                }
                
                if (!found) {
                    // Miss - necesitamos reemplazar una línea en el conjunto
                    explanation += `FALLO. Datos no encontrados en el conjunto.<br>`;
                    explanation += `Cargando datos desde memoria principal...<br>`;
                    
                    // Buscar línea para reemplazar (LRU simplificado)
                    let lruWay = 0;
                    let lruTime = set[0].accessTime;
                    
                    for (let way = 1; way < set.length; way++) {
                        if (set[way].accessTime < lruTime) {
                            lruWay = way;
                            lruTime = set[way].accessTime;
                        }
                    }
                    
                    // Reemplazar línea
                    set[lruWay].valid = true;
                    set[lruWay].tag = tag;
                    set[lruWay].data = data;
                    set[lruWay].accessTime = cacheState.accessCount;
                    
                    explanation += `Reemplazando vía ${lruWay} con etiqueta ${tag.toString(2).padStart(tagBits, '0')} y dato ${data}<br>`;
                }
                
            } else if (cacheState.type === 'fully-associative') {
                // Correspondencia totalmente asociativa
                const tag = address; // Toda la dirección es la etiqueta (sin índice)
                
                explanation += `Desglose de dirección:<br>`;
                explanation += `- Etiqueta: ${tag.toString(2).padStart(6, '0')} (${tag})<br>`;
                explanation += `- Desplazamiento: 0 (bloques de 1 palabra)<br><br>`;
                
                explanation += `Buscando en toda la caché...<br>`;
                
                let found = false;
                let emptyLine = -1;
                
                // Buscar en toda la caché
                for (let i = 0; i < cacheState.cache.length; i++) {
                    if (cacheState.cache[i].valid && cacheState.cache[i].tag === tag) {
                        // Hit
                        hit = true;
                        found = true;
                        cacheState.hitCount++;
                        cacheState.cache[i].accessTime = cacheState.accessCount;
                        explanation += `¡ACIERTO! Datos encontrados en línea ${i}: ${cacheState.cache[i].data}<br>`;
                        break;
                    }
                    
                    // Guardar primera línea vacía para posible uso
                    if (emptyLine === -1 && !cacheState.cache[i].valid) {
                        emptyLine = i;
                    }
                }
                
                if (!found) {
                    // Miss - necesitamos reemplazar una línea
                    explanation += `FALLO. Datos no encontrados en caché.<br>`;
                    explanation += `Cargando datos desde memoria principal...<br>`;
                    
                    let replaceLine = emptyLine;
                    
                    // Si no hay líneas vacías, usar LRU
                    if (replaceLine === -1) {
                        replaceLine = 0;
                        let lruTime = cacheState.cache[0].accessTime;
                        
                        for (let i = 1; i < cacheState.cache.length; i++) {
                            if (cacheState.cache[i].accessTime < lruTime) {
                                replaceLine = i;
                                lruTime = cacheState.cache[i].accessTime;
                            }
                        }
                    }
                    
                    // Reemplazar línea
                    cacheState.cache[replaceLine].valid = true;
                    cacheState.cache[replaceLine].tag = tag;
                    cacheState.cache[replaceLine].data = data;
                    cacheState.cache[replaceLine].accessTime = cacheState.accessCount;
                    
                    explanation += `${emptyLine !== -1 ? 'Usando' : 'Reemplazando'} línea ${replaceLine} con etiqueta ${tag.toString(2).padStart(6, '0')} y dato ${data}<br>`;
                }
            }
            
            // Actualizar UI
            document.getElementById('cache-explanation').innerHTML = explanation;
            document.getElementById('cache-log').innerHTML += `<br>Acceso ${cacheState.accessCount}: Dirección ${address} - ${hit ? 'ACIERTO' : 'FALLO'} - Dato: ${data}`;
            document.getElementById('cache-log').scrollTop = document.getElementById('cache-log').scrollHeight;
            
            updateCacheDisplay();
            
            // Crear animación simple
            const animationDiv = document.getElementById('cache-animation');
            const hitMissDiv = document.createElement('div');
            hitMissDiv.style.padding = '20px';
            hitMissDiv.style.fontSize = '24px';
            hitMissDiv.style.textAlign = 'center';
            hitMissDiv.style.backgroundColor = hit ? '#4CAF50' : '#f44336';
            hitMissDiv.style.color = 'white';
            hitMissDiv.textContent = hit ? '¡ACIERTO EN CACHÉ!' : 'FALLO EN CACHÉ';
            animationDiv.appendChild(hitMissDiv);
        }
        
        // Reiniciar caché
        function resetCache() {
            initializeCache();
            document.getElementById('cache-explanation').innerHTML = '';
            document.getElementById('cache-log').innerHTML = 'Caché reiniciada.';
            document.getElementById('cache-animation').innerHTML = '';
        }
        
        // ========== FUNCIONES GENERALES ==========
        
        // Cambiar entre pestañas
        function openTab(tabName) {
            // Ocultar todas las pestañas
            const tabContents = document.getElementsByClassName('tab-content');
            for (let i = 0; i < tabContents.length; i++) {
                tabContents[i].classList.remove('active');
            }
            
            // Desactivar todos los botones
            const tabButtons = document.getElementsByClassName('tab-button');
            for (let i = 0; i < tabButtons.length; i++) {
                tabButtons[i].classList.remove('active');
            }
            
            // Activar pestaña seleccionada
            document.getElementById(tabName).classList.add('active');
            event.currentTarget.classList.add('active');
        }
        
        // Inicializar la aplicación
        window.onload = function() {
            initializeMemory();
            updateCacheConfig();
        };
    </script>
</body>
</html>